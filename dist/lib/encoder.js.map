{"version":3,"file":"encoder.js","sourceRoot":"/","sources":["lib/encoder.ts"],"names":[],"mappings":";AAAA;;8DAE8D;;AAE9D,2CAAoC;AAEpC,MAAqB,YAAY;IAC/B,MAAM,CAAC,UAAoB;QACzB,OAAO,UAAU;aACd,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;aAC1B,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC;aAC/B,IAAI,EAAE;aACN,MAAM,CACL,CACE,MAAgB,EAChB,KAAa,EACb,KAAa,EACb,UAAoB,EACpB,EAAE;YACF,IAAI,KAAK,KAAK,CAAC,EAAE;gBACf,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,CAAC;aAC1B;iBAAM;gBACL,MAAM,IAAI,GAAW,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;gBAC3C,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBACxD,IAAI,YAAY,CAAC,MAAM,IAAI,iBAAK,EAAE;oBAChC,MAAM,IAAI,KAAK,CAAC,iBAAiB,KAAK,KAAK,iBAAK,uDAAuD,CAAC,CAAC;iBAC1G;gBACD,MAAM,CAAC,IAAI,CACT,GAAG,YAAY,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAK,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,CAC5E,CAAC;aACH;YACD,OAAO,MAAM,CAAC;QAChB,CAAC,EACD,EAAE,CACH,CAAC;IACN,CAAC;IAEO,gBAAgB,CAAC,KAAa,EAAE,MAAc;QACpD,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;YAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;gBACxC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;aAC3B;iBAAM;gBACL,OAAO,MAAM,CAAC;aACf;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA3CD,+BA2CC","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport { RADIX } from './constants';\n\nexport default class FrontEncoder {\n  encode(dictionary: string[]) {\n    return dictionary\n      .map(entry => entry.trim())\n      .filter(entry => !!entry.length)\n      .sort()\n      .reduce(\n        (\n          result: string[],\n          entry: string,\n          index: number,\n          dictionary: string[]\n        ) => {\n          if (index === 0) {\n            result.push(`0${entry}`);\n          } else {\n            const prev: string = dictionary[index - 1];\n            const commonPrefix = this.findCommonPrefix(prev, entry);\n            if (commonPrefix.length >= RADIX) {\n              throw new Error(`Cannot encode ${entry}, ${RADIX} or more characters are shared with the previous word`);\n            }\n            result.push(\n              `${commonPrefix.length.toString(RADIX)}${entry.slice(commonPrefix.length)}`\n            );\n          }\n          return result;\n        },\n        []\n      );\n  }\n\n  private findCommonPrefix(first: string, second: string): string {\n    let prefix = \"\";\n    let max = Math.min(first.length, second.length);\n    for (let i = 0; i < max; ++i) {\n      if (first.charAt(i) === second.charAt(i)) {\n        prefix += first.charAt(i);\n      } else {\n        return prefix;\n      }\n    }\n    return prefix;\n  }\n}\n"]}